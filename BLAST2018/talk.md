# On the Complexity of Computing Difference Terms and Operations

**Keywords**. idempotent equational class; difference term; Malcev condition; 
computational complexity

**Abstract.**   
At BLAST 2017 we presented a positive answer to the following practical question:  

    Given a finite idempotent algebra, can we efficiently decide whether 
	the variety generated by that algebra has a difference term? 

We present a new practical result related to this problem. Specifically, we 
discuss the complexity of constructing a difference term *d* for V(__A__) and show that, 
although *d*  may have exponential length, nonetheless there is a polynomial-time 
algorithm that takes as input any algebra **B** in V(__A__) and produces the operation 
table for *d* interpreted in **AUTHORS**.

+ **William DeMeo**     | University of Colorado, Boulder | http://williamdemeo.org       |
+ **Ralph Freese**      | University of Hawaii, Manoa     | http://math.hawaii.edu/~ralph |
+ **Matthew Valeriote** | McMaster University             | https://ms.mcmaster.ca/~matt  |

---

# Part I


```lean
import basic
section term

	parameters (S : signature) (X : Type*)

	inductive term
	| var     : X → term
	| app (f) : (S.ρ f → term) → term

	def free : algebra S :=	⟨term, term.app⟩

end term
```
```lean
section free
	parameters {S : signature} (A : algebra S) (X : Type*)
	def free_ := free S X
	def var_  := @var S X

        -- Free algebra is really free: existence & uniqueness of homomorphism
	    parameter (h : X → A)

	    def imap : free_ → A
		| (var .(S) x) := h x
		| (app f a)    := A f (λ x, imap $ a x)

	    lemma imap_is_hom : homomorphic imap :=
			λ f a, show imap (app f a) = A f (imap ∘ a), from rfl

	lemma hom_unique : ∀ {α β : free_ → A},
		homomorphic α → homomorphic β → α ∘ var_ = β ∘ var_ → α = β :=
	begin
		assume (α β : free_ → A) (hα : homomorphic α) (hβ : homomorphic β)
		(h : α ∘ var_ = β ∘ var_),
  	    funext t, show α t = β t,
  	    induction t with t f a ih,
		show α (var_ t) = β (var_ t),
		{ apply congr_fun h t },

	    show α (app f a) = β (app f a),
		{ have ih' : α ∘ a = β ∘ a, from funext ih,
	   	calc α (app f a) = A f (α ∘ a) : hα f a
                     ... = A f (β ∘ a) : congr_arg (A f) ih'
                     ... = β (app f a) : (hβ f a).symm }
	end
end
```



